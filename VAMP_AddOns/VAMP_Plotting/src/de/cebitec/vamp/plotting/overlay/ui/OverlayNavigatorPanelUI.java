/*
 * Maui, Maltcms User Interface. 
 * Copyright (C) 2008-2012, The authors of Maui. All rights reserved.
 *
 * Project website: http://maltcms.sf.net
 *
 * Maui may be used under the terms of either the
 *
 * GNU Lesser General Public License (LGPL)
 * http://www.gnu.org/licenses/lgpl.html
 *
 * or the
 *
 * Eclipse Public License (EPL)
 * http://www.eclipse.org/org/documents/epl-v10.php
 *
 * As a user/recipient of Maui, you may choose which license to receive the code 
 * under. Certain files or entire directories may not be covered by this 
 * dual license, but are subject to licenses compatible to both LGPL and EPL.
 * License exceptions are explicitly declared in all relevant files or in a 
 * LICENSE file in the relevant directories.
 *
 * Maui is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE. Please consult the relevant license documentation
 * for details.
 */
package de.cebitec.vamp.plotting.overlay.ui;

import de.cebitec.vamp.plotting.api.overlay.ChartOverlay;
import java.awt.BorderLayout;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.List;
import javax.swing.ActionMap;
import org.netbeans.swing.outline.Outline;
import org.openide.explorer.ExplorerManager;
import org.openide.explorer.ExplorerUtils;
import org.openide.explorer.view.OutlineView;
import org.openide.nodes.AbstractNode;
import org.openide.nodes.ChildFactory;
import org.openide.nodes.Children;
import org.openide.nodes.FilterNode;
import org.openide.nodes.Node;
import org.openide.util.Lookup;

/**
 *
 * @author Nils Hoffmann
 */
public class OverlayNavigatorPanelUI extends javax.swing.JPanel implements ExplorerManager.Provider, Lookup.Provider {

    private ExplorerManager manager = new ExplorerManager();
    private OutlineView outline = null;
    private boolean expand = true;
    private Lookup lookup;

    /**
     * Creates new form OverlayNavigatorPanelUI
     */
    public OverlayNavigatorPanelUI() {
        ActionMap map = getActionMap();
        initComponents();
        outline = new OutlineView("Overlays");
        Outline o = outline.getOutline();
        o.setRootVisible(false);
        add(outline, BorderLayout.CENTER);
        lookup = ExplorerUtils.createLookup(manager, map);
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        setLayout(new java.awt.BorderLayout());
    }// </editor-fold>//GEN-END:initComponents
    // Variables declaration - do not modify//GEN-BEGIN:variables
    // End of variables declaration//GEN-END:variables

    @Override
    public ExplorerManager getExplorerManager() {
        return manager;
    }

    @Override
    public Lookup getLookup() {
        return lookup;
    }

    @Override
    public void addNotify() {
        super.addNotify();
        ExplorerUtils.activateActions(manager, true);
    }

    @Override
    public void removeNotify() {
        ExplorerUtils.activateActions(manager, false);
        super.removeNotify();
    }

    public void setContent(Collection<? extends Node> overlays) {
        if (overlays.isEmpty() || overlays == null) {
            manager.setRootContext(Node.EMPTY);
        } else {
            final List<Node> l = new ArrayList<>(overlays);
            Collections.sort(l, new Comparator<Node>() {
                @Override
                public int compare(Node t, Node t1) {
                    ChartOverlay lhs = t.getLookup().lookup(ChartOverlay.class);
                    ChartOverlay rhs = t1.getLookup().lookup(ChartOverlay.class);
                    if ((lhs == null || rhs == null) || (lhs == null && rhs == null)) {
                        return 0;
                    }
                    return lhs.getLayerPosition() - rhs.getLayerPosition();
                }
            });
            Node root = new AbstractNode(Children.create(new ChildFactory<Node>() {

                @Override
                protected boolean createKeys(List<Node> list) {
                    list.addAll(l);
                    return true;
                }

                @Override
                protected Node createNodeForKey(Node key) {
                    return new FilterNode(key);
                }
                
            }, true));
            manager.setRootContext(root);
        }
    }
}
