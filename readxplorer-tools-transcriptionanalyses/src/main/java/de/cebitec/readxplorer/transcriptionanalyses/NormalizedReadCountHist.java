/*
 * Copyright (C) 2015 Rolf Hilker <rolf.hilker at mikrobio.med.uni-giessen.de>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

package de.cebitec.readxplorer.transcriptionanalyses;


import de.cebitec.readxplorer.transcriptionanalyses.datastructures.NormalizedReadCount;
import de.cebitec.readxplorer.utils.MathUtils;
import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.event.ComponentEvent;
import java.awt.event.ComponentListener;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Locale;
import javax.swing.JPanel;
import org.jfree.chart.ChartFactory;
import org.jfree.chart.ChartPanel;
import org.jfree.chart.JFreeChart;
import org.jfree.chart.StandardChartTheme;
import org.jfree.chart.axis.CategoryLabelPositions;
import org.jfree.chart.axis.LogAxis;
import org.jfree.chart.axis.LogarithmicAxis;
import org.jfree.chart.axis.NumberAxis;
import org.jfree.chart.axis.TickUnitSource;
import org.jfree.chart.labels.StandardCategoryToolTipGenerator;
import org.jfree.chart.plot.PlotOrientation;
import org.jfree.chart.renderer.category.BarRenderer;
import org.jfree.data.category.CategoryDataset;
import org.jfree.data.category.DefaultCategoryDataset;


/**
 * Histogram panel for displaying a histogram of TPM or RPKM values.
 *
 * @author Rolf Hilker <rolf.hilker at mikrobio.med.uni-giessen.de>
 */
public class NormalizedReadCountHist extends JPanel implements ComponentListener {

    private static final long serialVersionUID = 1L;

    private static final String TPM = "TPM";
    private static final String RPKM = "RPKM";

    private JPanel plotPanel;
    private final NormalizationAnalysisResult normalizationResult;
    private boolean isRPKM = false;


    /**
     * Histogram panel for displaying a histogram of TPM or RPKM values.
     *
     * @param normalizationResult result of TPM or RPKM values
     */
    public NormalizedReadCountHist( NormalizationAnalysisResult normalizationResult ) {
        initComponents();
        initSwingComponents();
        this.normalizationResult = normalizationResult;
        
        drawChart(plotPanel, isRPKM);
        
        String buttonType = isRPKM ? TPM : RPKM;
        switchButton.setText( "Switch to " + buttonType );
        
        addComponentListener( this );
    }


    /** This method is called from within the constructor to initialize the
     * form. WARNING: Do NOT modify this code. The content of this method is
     * always regenerated by the Form Editor.
     */
    @SuppressWarnings( "unchecked" )
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        switchButton = new javax.swing.JButton();
        mainPanel = new javax.swing.JPanel();

        setName(""); // NOI18N

        org.openide.awt.Mnemonics.setLocalizedText(switchButton, org.openide.util.NbBundle.getMessage(NormalizedReadCountHist.class, "NormalizedReadCountHist.text")); // NOI18N
        switchButton.setName(""); // NOI18N
        switchButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                switchButtonActionPerformed(evt);
            }
        });

        mainPanel.setLayout(new java.awt.BorderLayout());

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);
        this.setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addComponent(switchButton)
                .addGap(0, 296, Short.MAX_VALUE))
            .addComponent(mainPanel, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addComponent(switchButton)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(mainPanel, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );
    }// </editor-fold>//GEN-END:initComponents

    private void switchButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_switchButtonActionPerformed
        isRPKM = !isRPKM;
        String buttonType = isRPKM ? TPM : RPKM;
        switchButton.setText( "Switch to " + buttonType );
        
        drawChart(plotPanel, isRPKM);
    }//GEN-LAST:event_switchButtonActionPerformed


    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JPanel mainPanel;
    private javax.swing.JButton switchButton;
    // End of variables declaration//GEN-END:variables


    @Override
    public void componentHidden( ComponentEvent e ) {

    }


    @Override
    public void componentMoved( ComponentEvent e ) {

    }


    @Override
    public void componentResized( ComponentEvent e ) {
        this.plotPanel.validate();
    }


    @Override
    public void componentShown( ComponentEvent e ) {

    }


    /**
     * Initializes the swing components of this panel.
     */
    private void initSwingComponents() {
        plotPanel = new JPanel(new BorderLayout());
        mainPanel.add( plotPanel, BorderLayout.CENTER );
    }
    
    private void drawChart(JPanel plotPanel, boolean isRPKM) {
        plotPanel.removeAll();
        JFreeChart chart = createHistogram(isRPKM);
        ChartPanel panel = new ChartPanel( chart, true, false, true, true, true );
        panel.setInitialDelay( 0 );
        panel.setMouseWheelEnabled( true );
        panel.setMouseZoomable( true );
        plotPanel.add( panel, BorderLayout.CENTER );
    }
    
    private JFreeChart createHistogram(boolean useRPKM) {
        String tpmOrRpkm =  isRPKM ? "RPKM" : "TPM";
        double max = 0;
        double min = Integer.MAX_VALUE;
        List<Double> rpkmList = new ArrayList<>();
        List<NormalizedReadCount> normResults = normalizationResult.getResults();
        for( NormalizedReadCount rpkmValue : normResults ) {
            double rpkm = useRPKM ? rpkmValue.getRPKM() : rpkmValue.getTPM();
            if( rpkm < min ) {
                min = rpkm;
            }
            if( rpkm >= max ) {
                max = rpkm;
            }
            rpkmList.add( rpkm );
        }
        Collections.sort( rpkmList );

        int[] intervals = new int[21]; //intervals of bars that are shown later
        for( int l = 0; l < intervals.length; l++ ) {
            intervals[l] = 0;
        }

        //calculate quantile borders for useful resolution of the histogram
        double quantileBorder20 = Math.ceil(MathUtils.getQuantileBorder( 0.2, rpkmList ));
        double quantileBorder90 = Math.floor(MathUtils.getQuantileBorder( 0.9, rpkmList ));
        double shift20 = quantileBorder20 / 5;
        double shift90 = quantileBorder90 / 13;
        double shiftLargest = (max + 0.1) / 3;

        //add rpkm values into their corresponding interval = histogram bar
        for( NormalizedReadCount normValue : normResults ) {
            double value = isRPKM ? normValue.getRPKM() : normValue.getTPM();
            int index;
            if( value <= quantileBorder20 ) {
                index = (int) Math.floor( value / shift20 );
            } else if( value <= quantileBorder90 ) {
                index = 5 + (int) Math.floor( value / shift90 );
            } else {
                index = 18 + (int) Math.floor( value / shiftLargest );
            }
            intervals[index]++;
        }
        
        double[] categories = new double[22];
        for (int i= 0; i < 6; i++) {
            categories[i] = Math.round(i * shift20 * 100) / 100.0;
        }
        for (int i= 1; i < 14; i++) {
            categories[5 + i] = Math.round((categories[5] + i * shift90) * 100) / 100.0;
        }
        for (int i= 1; i < 4; i++) {
            categories[18 + i] = Math.round((categories[18] + i * shiftLargest) * 100) / 100.0;
        }

        DefaultCategoryDataset dataset = new DefaultCategoryDataset();
        for( int i = 0; i < intervals.length; i++ ) {
            dataset.addValue( intervals[i], tpmOrRpkm, categories[i] + " - " + categories[i+1] );
        }
        
        StandardChartTheme theme = new StandardChartTheme("Histogram RX", true);
        theme.setChartBackgroundPaint(Color.WHITE);
        theme.setPlotBackgroundPaint(new Color(220,220,220));
        ChartFactory.setChartTheme(theme);

        JFreeChart chart = ChartFactory.createBarChart(
                "", //Chart Title  
                tpmOrRpkm + " Value Ranges", // Category axis  
                "Number Of Features", // Value axis  
                dataset,
                PlotOrientation.VERTICAL,
                true, true, false
        );
        chart.removeLegend();
        BarRenderer renderer = (BarRenderer) chart.getCategoryPlot().getRenderer();
        renderer.setSeriesPaint(0, new Color(239, 204, 0));
        
        final NumberAxis rangeAxis;
        final TickUnitSource tus;
        rangeAxis = new LogarithmicAxis("Number Of Features");
        ((LogarithmicAxis) rangeAxis).setStrictValuesFlag(false);
        tus = LogAxis.createLogTickUnits(Locale.getDefault());
        rangeAxis.setStandardTickUnits(tus);
        chart.getCategoryPlot().setRangeAxis(rangeAxis);
        
        chart.getCategoryPlot().getDomainAxis().setCategoryLabelPositions(CategoryLabelPositions.DOWN_90);
        chart.getCategoryPlot().getDomainAxis().setMaximumCategoryLabelLines(2);
        
        StandardCategoryToolTipGenerator categoryToolTipGenerator = new StandardCategoryToolTipGenerator() {
            @Override
            public String generateToolTip(CategoryDataset dataset, int row, int column) {
                Number value = dataset.getValue(row, column);
                return "# features: " + value;
            }
        };
        renderer.setBaseToolTipGenerator(categoryToolTipGenerator);

        return chart;
    }
}
